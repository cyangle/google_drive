#  Drive API
#
# Manages files in Drive including uploading, downloading, searching, detecting changes, and updating sharing permissions.
#
# The version of the OpenAPI document: v3
#
# Generated by: https://openapi-generator.tech
#

require "uri"

module GoogleDrive
  class FilesApi
    property api_client : ApiClient

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end

    # Creates a copy of a file and applies any requested updates with patch semantics. Folders cannot be copied.
    # @param file_id [String] The ID of the file.
    # @return [File]
    def copy(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, file : File? = nil)
      data, _status_code, _headers = copy_with_http_info(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, ignore_default_visibility: ignore_default_visibility, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, file: file)
      data
    end

    # Creates a copy of a file and applies any requested updates with patch semantics. Folders cannot be copied.
    # @param file_id [String] The ID of the file.
    # @return [Array<(File, Integer, Hash)>] File data, response status code and response headers
    def copy_with_http_info(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, file : File? = nil)
      request = build_api_request_for_copy(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, ignore_default_visibility: ignore_default_visibility, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, file: file)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#copy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return File.from_json(data), status_code, headers
    end

    # Creates a copy of a file and applies any requested updates with patch semantics. Folders cannot be copied.
    # @param file_id [String] The ID of the file.
    # @return nil
    def copy(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, file : File? = nil, &block : Crest::Response ->)
      build_api_request_for_copy(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, ignore_default_visibility: ignore_default_visibility, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, file: file).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_copy(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, file : File? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.copy ..." }
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/drive/v3/files/{fileId}/copy".sub("{" + "fileId" + "}", URI.encode_path(file_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["enforceSingleParent"] = enforce_single_parent.to_s if !enforce_single_parent.nil?
      query_params["ignoreDefaultVisibility"] = ignore_default_visibility.to_s if !ignore_default_visibility.nil?
      query_params["includePermissionsForView"] = include_permissions_for_view.to_s if !include_permissions_for_view.nil?
      query_params["keepRevisionForever"] = keep_revision_forever.to_s if !keep_revision_forever.nil?
      query_params["ocrLanguage"] = ocr_language.to_s if !ocr_language.nil?
      query_params["supportsAllDrives"] = supports_all_drives.to_s if !supports_all_drives.nil?
      query_params["supportsTeamDrives"] = supports_team_drives.to_s if !supports_team_drives.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = file.to_json

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "FilesApi.drive_files_copy",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Creates a new file.
    # @return [File]
    def create(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, file : File? = nil)
      data, _status_code, _headers = create_with_http_info(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, ignore_default_visibility: ignore_default_visibility, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, file: file)
      data
    end

    # Creates a new file.
    # @return [Array<(File, Integer, Hash)>] File data, response status code and response headers
    def create_with_http_info(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, file : File? = nil)
      request = build_api_request_for_create(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, ignore_default_visibility: ignore_default_visibility, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, file: file)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return File.from_json(data), status_code, headers
    end

    # Creates a new file.
    # @return nil
    def create(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, file : File? = nil, &block : Crest::Response ->)
      build_api_request_for_create(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, ignore_default_visibility: ignore_default_visibility, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, file: file).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_create(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, file : File? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.create ..." }
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/drive/v3/files"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["enforceSingleParent"] = enforce_single_parent.to_s if !enforce_single_parent.nil?
      query_params["ignoreDefaultVisibility"] = ignore_default_visibility.to_s if !ignore_default_visibility.nil?
      query_params["includePermissionsForView"] = include_permissions_for_view.to_s if !include_permissions_for_view.nil?
      query_params["keepRevisionForever"] = keep_revision_forever.to_s if !keep_revision_forever.nil?
      query_params["ocrLanguage"] = ocr_language.to_s if !ocr_language.nil?
      query_params["supportsAllDrives"] = supports_all_drives.to_s if !supports_all_drives.nil?
      query_params["supportsTeamDrives"] = supports_team_drives.to_s if !supports_team_drives.nil?
      query_params["useContentAsIndexableText"] = use_content_as_indexable_text.to_s if !use_content_as_indexable_text.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/octet-stream"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = file.to_json

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "FilesApi.drive_files_create",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive the user must be an organizer on the parent. If the target is a folder, all descendants owned by the user are also deleted.
    # @param file_id [String] The ID of the file.
    # @return [nil]
    def delete(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil)
      delete_with_http_info(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives)
      nil
    end

    # Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive the user must be an organizer on the parent. If the target is a folder, all descendants owned by the user are also deleted.
    # @param file_id [String] The ID of the file.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_with_http_info(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil)
      request = build_api_request_for_delete(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return nil, status_code, headers
    end

    # Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive the user must be an organizer on the parent. If the target is a folder, all descendants owned by the user are also deleted.
    # @param file_id [String] The ID of the file.
    # @return nil
    def delete(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_delete(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_delete(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.delete ..." }
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/drive/v3/files/{fileId}".sub("{" + "fileId" + "}", URI.encode_path(file_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["enforceSingleParent"] = enforce_single_parent.to_s if !enforce_single_parent.nil?
      query_params["supportsAllDrives"] = supports_all_drives.to_s if !supports_all_drives.nil?
      query_params["supportsTeamDrives"] = supports_team_drives.to_s if !supports_team_drives.nil?

      # header parameters
      header_params = Hash(String, String).new

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "FilesApi.drive_files_delete",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Permanently deletes all of the user's trashed files.
    # @return [nil]
    def empty_trash(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil)
      empty_trash_with_http_info(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent)
      nil
    end

    # Permanently deletes all of the user&#39;s trashed files.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def empty_trash_with_http_info(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil)
      request = build_api_request_for_empty_trash(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#empty_trash\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return nil, status_code, headers
    end

    # Permanently deletes all of the user&#39;s trashed files.
    # @return nil
    def empty_trash(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_empty_trash(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_empty_trash(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.empty_trash ..." }
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/drive/v3/files/trash"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["enforceSingleParent"] = enforce_single_parent.to_s if !enforce_single_parent.nil?

      # header parameters
      header_params = Hash(String, String).new

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "FilesApi.drive_files_empty_trash",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.
    # @param file_id [String] The ID of the file.
    # @param mime_type [String] The MIME type of the format requested for this export.
    # @return [nil]
    def export(*, file_id : String, mime_type : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil)
      export_with_http_info(file_id: file_id, mime_type: mime_type, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip)
      nil
    end

    # Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.
    # @param file_id [String] The ID of the file.
    # @param mime_type [String] The MIME type of the format requested for this export.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def export_with_http_info(*, file_id : String, mime_type : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil)
      request = build_api_request_for_export(file_id: file_id, mime_type: mime_type, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#export\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return nil, status_code, headers
    end

    # Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.
    # @param file_id [String] The ID of the file.
    # @param mime_type [String] The MIME type of the format requested for this export.
    # @return nil
    def export(*, file_id : String, mime_type : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, &block : Crest::Response ->)
      build_api_request_for_export(file_id: file_id, mime_type: mime_type, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_export(*, file_id : String, mime_type : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.export ..." }
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/drive/v3/files/{fileId}/export".sub("{" + "fileId" + "}", URI.encode_path(file_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["mimeType"] = mime_type.to_s if !mime_type.nil?

      # header parameters
      header_params = Hash(String, String).new

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "FilesApi.drive_files_export",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Generates a set of file IDs which can be provided in create or copy requests.
    # @return [GeneratedIds]
    def generate_ids(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, count : Int32? = nil, space : String? = nil, _type : String? = nil)
      data, _status_code, _headers = generate_ids_with_http_info(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, count: count, space: space, _type: _type)
      data
    end

    # Generates a set of file IDs which can be provided in create or copy requests.
    # @return [Array<(GeneratedIds, Integer, Hash)>] GeneratedIds data, response status code and response headers
    def generate_ids_with_http_info(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, count : Int32? = nil, space : String? = nil, _type : String? = nil)
      request = build_api_request_for_generate_ids(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, count: count, space: space, _type: _type)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#generate_ids\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return GeneratedIds.from_json(data), status_code, headers
    end

    # Generates a set of file IDs which can be provided in create or copy requests.
    # @return nil
    def generate_ids(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, count : Int32? = nil, space : String? = nil, _type : String? = nil, &block : Crest::Response ->)
      build_api_request_for_generate_ids(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, count: count, space: space, _type: _type).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_generate_ids(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, count : Int32? = nil, space : String? = nil, _type : String? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.generate_ids ..." }
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      if @api_client.config.client_side_validation && !count.nil? && count > 1000
        raise ArgumentError.new("invalid value for \"count\" when calling FilesApi.generate_ids, must be smaller than or equal to 1000.")
      end

      if @api_client.config.client_side_validation && !count.nil? && count < 1
        raise ArgumentError.new("invalid value for \"count\" when calling FilesApi.generate_ids, must be greater than or equal to 1.")
      end

      # resource path
      local_var_path = "/drive/v3/files/generateIds"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["count"] = count.to_s if !count.nil?
      query_params["space"] = space.to_s if !space.nil?
      query_params["type"] = _type.to_s if !_type.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "FilesApi.drive_files_generate_ids",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Gets a file's metadata or content by ID.
    # @param file_id [String] The ID of the file.
    # @return [File]
    def get(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, acknowledge_abuse : Bool? = nil, include_permissions_for_view : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil)
      data, _status_code, _headers = get_with_http_info(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, acknowledge_abuse: acknowledge_abuse, include_permissions_for_view: include_permissions_for_view, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives)
      data
    end

    # Gets a file&#39;s metadata or content by ID.
    # @param file_id [String] The ID of the file.
    # @return [Array<(File, Integer, Hash)>] File data, response status code and response headers
    def get_with_http_info(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, acknowledge_abuse : Bool? = nil, include_permissions_for_view : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil)
      request = build_api_request_for_get(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, acknowledge_abuse: acknowledge_abuse, include_permissions_for_view: include_permissions_for_view, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return File.from_json(data), status_code, headers
    end

    # Gets a file&#39;s metadata or content by ID.
    # @param file_id [String] The ID of the file.
    # @return nil
    def get(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, acknowledge_abuse : Bool? = nil, include_permissions_for_view : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_get(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, acknowledge_abuse: acknowledge_abuse, include_permissions_for_view: include_permissions_for_view, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, acknowledge_abuse : Bool? = nil, include_permissions_for_view : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.get ..." }
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/drive/v3/files/{fileId}".sub("{" + "fileId" + "}", URI.encode_path(file_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["acknowledgeAbuse"] = acknowledge_abuse.to_s if !acknowledge_abuse.nil?
      query_params["includePermissionsForView"] = include_permissions_for_view.to_s if !include_permissions_for_view.nil?
      query_params["supportsAllDrives"] = supports_all_drives.to_s if !supports_all_drives.nil?
      query_params["supportsTeamDrives"] = supports_team_drives.to_s if !supports_team_drives.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "FilesApi.drive_files_get",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Lists or searches files.
    # @return [FileList]
    def list(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, corpora : String? = nil, corpus : String? = nil, drive_id : String? = nil, include_items_from_all_drives : Bool? = nil, include_permissions_for_view : String? = nil, include_team_drive_items : Bool? = nil, order_by : String? = nil, page_size : Int32? = nil, page_token : String? = nil, q : String? = nil, spaces : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, team_drive_id : String? = nil)
      data, _status_code, _headers = list_with_http_info(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, corpora: corpora, corpus: corpus, drive_id: drive_id, include_items_from_all_drives: include_items_from_all_drives, include_permissions_for_view: include_permissions_for_view, include_team_drive_items: include_team_drive_items, order_by: order_by, page_size: page_size, page_token: page_token, q: q, spaces: spaces, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, team_drive_id: team_drive_id)
      data
    end

    # Lists or searches files.
    # @return [Array<(FileList, Integer, Hash)>] FileList data, response status code and response headers
    def list_with_http_info(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, corpora : String? = nil, corpus : String? = nil, drive_id : String? = nil, include_items_from_all_drives : Bool? = nil, include_permissions_for_view : String? = nil, include_team_drive_items : Bool? = nil, order_by : String? = nil, page_size : Int32? = nil, page_token : String? = nil, q : String? = nil, spaces : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, team_drive_id : String? = nil)
      request = build_api_request_for_list(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, corpora: corpora, corpus: corpus, drive_id: drive_id, include_items_from_all_drives: include_items_from_all_drives, include_permissions_for_view: include_permissions_for_view, include_team_drive_items: include_team_drive_items, order_by: order_by, page_size: page_size, page_token: page_token, q: q, spaces: spaces, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, team_drive_id: team_drive_id)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return FileList.from_json(data), status_code, headers
    end

    # Lists or searches files.
    # @return nil
    def list(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, corpora : String? = nil, corpus : String? = nil, drive_id : String? = nil, include_items_from_all_drives : Bool? = nil, include_permissions_for_view : String? = nil, include_team_drive_items : Bool? = nil, order_by : String? = nil, page_size : Int32? = nil, page_token : String? = nil, q : String? = nil, spaces : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, team_drive_id : String? = nil, &block : Crest::Response ->)
      build_api_request_for_list(alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, corpora: corpora, corpus: corpus, drive_id: drive_id, include_items_from_all_drives: include_items_from_all_drives, include_permissions_for_view: include_permissions_for_view, include_team_drive_items: include_team_drive_items, order_by: order_by, page_size: page_size, page_token: page_token, q: q, spaces: spaces, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, team_drive_id: team_drive_id).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_list(*, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, corpora : String? = nil, corpus : String? = nil, drive_id : String? = nil, include_items_from_all_drives : Bool? = nil, include_permissions_for_view : String? = nil, include_team_drive_items : Bool? = nil, order_by : String? = nil, page_size : Int32? = nil, page_token : String? = nil, q : String? = nil, spaces : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, team_drive_id : String? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.list ..." }
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      allowable_values = ["domain", "user"]
      if @api_client.config.client_side_validation && !corpus.nil? && !allowable_values.includes?(corpus)
        raise ArgumentError.new("invalid value for \"corpus\", must be one of #{allowable_values}")
      end
      if @api_client.config.client_side_validation && !page_size.nil? && page_size > 1000
        raise ArgumentError.new("invalid value for \"page_size\" when calling FilesApi.list, must be smaller than or equal to 1000.")
      end

      if @api_client.config.client_side_validation && !page_size.nil? && page_size < 1
        raise ArgumentError.new("invalid value for \"page_size\" when calling FilesApi.list, must be greater than or equal to 1.")
      end

      # resource path
      local_var_path = "/drive/v3/files"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["corpora"] = corpora.to_s if !corpora.nil?
      query_params["corpus"] = corpus.to_s if !corpus.nil?
      query_params["driveId"] = drive_id.to_s if !drive_id.nil?
      query_params["includeItemsFromAllDrives"] = include_items_from_all_drives.to_s if !include_items_from_all_drives.nil?
      query_params["includePermissionsForView"] = include_permissions_for_view.to_s if !include_permissions_for_view.nil?
      query_params["includeTeamDriveItems"] = include_team_drive_items.to_s if !include_team_drive_items.nil?
      query_params["orderBy"] = order_by.to_s if !order_by.nil?
      query_params["pageSize"] = page_size.to_s if !page_size.nil?
      query_params["pageToken"] = page_token.to_s if !page_token.nil?
      query_params["q"] = q.to_s if !q.nil?
      query_params["spaces"] = spaces.to_s if !spaces.nil?
      query_params["supportsAllDrives"] = supports_all_drives.to_s if !supports_all_drives.nil?
      query_params["supportsTeamDrives"] = supports_team_drives.to_s if !supports_team_drives.nil?
      query_params["teamDriveId"] = team_drive_id.to_s if !team_drive_id.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "FilesApi.drive_files_list",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.
    # @param file_id [String] The ID of the file.
    # @return [File]
    def update(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, add_parents : String? = nil, enforce_single_parent : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, remove_parents : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, file : File? = nil)
      data, _status_code, _headers = update_with_http_info(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, add_parents: add_parents, enforce_single_parent: enforce_single_parent, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, remove_parents: remove_parents, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, file: file)
      data
    end

    # Updates a file&#39;s metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.
    # @param file_id [String] The ID of the file.
    # @return [Array<(File, Integer, Hash)>] File data, response status code and response headers
    def update_with_http_info(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, add_parents : String? = nil, enforce_single_parent : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, remove_parents : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, file : File? = nil)
      request = build_api_request_for_update(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, add_parents: add_parents, enforce_single_parent: enforce_single_parent, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, remove_parents: remove_parents, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, file: file)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#update\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return File.from_json(data), status_code, headers
    end

    # Updates a file&#39;s metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.
    # @param file_id [String] The ID of the file.
    # @return nil
    def update(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, add_parents : String? = nil, enforce_single_parent : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, remove_parents : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, file : File? = nil, &block : Crest::Response ->)
      build_api_request_for_update(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, add_parents: add_parents, enforce_single_parent: enforce_single_parent, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, remove_parents: remove_parents, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, file: file).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_update(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, add_parents : String? = nil, enforce_single_parent : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, remove_parents : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, file : File? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.update ..." }
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/drive/v3/files/{fileId}".sub("{" + "fileId" + "}", URI.encode_path(file_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["addParents"] = add_parents.to_s if !add_parents.nil?
      query_params["enforceSingleParent"] = enforce_single_parent.to_s if !enforce_single_parent.nil?
      query_params["includePermissionsForView"] = include_permissions_for_view.to_s if !include_permissions_for_view.nil?
      query_params["keepRevisionForever"] = keep_revision_forever.to_s if !keep_revision_forever.nil?
      query_params["ocrLanguage"] = ocr_language.to_s if !ocr_language.nil?
      query_params["removeParents"] = remove_parents.to_s if !remove_parents.nil?
      query_params["supportsAllDrives"] = supports_all_drives.to_s if !supports_all_drives.nil?
      query_params["supportsTeamDrives"] = supports_team_drives.to_s if !supports_team_drives.nil?
      query_params["useContentAsIndexableText"] = use_content_as_indexable_text.to_s if !use_content_as_indexable_text.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = file.to_json

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"PATCH",
        path: local_var_path,
        operation: "FilesApi.drive_files_update",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.
    # @param upload_type [String] The type of upload request to the /upload URI
    # @param file_id [String] The ID of the file.
    # @return [File]
    def update_content(*, upload_type : String = "media", file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, add_parents : String? = nil, enforce_single_parent : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, remove_parents : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, body : ::File? = nil)
      data, _status_code, _headers = update_content_with_http_info(upload_type: upload_type, file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, add_parents: add_parents, enforce_single_parent: enforce_single_parent, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, remove_parents: remove_parents, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, body: body)
      data
    end

    # Updates a file&#39;s metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.
    # @param upload_type [String] The type of upload request to the /upload URI
    # @param file_id [String] The ID of the file.
    # @return [Array<(File, Integer, Hash)>] File data, response status code and response headers
    def update_content_with_http_info(*, upload_type : String = "media", file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, add_parents : String? = nil, enforce_single_parent : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, remove_parents : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, body : ::File? = nil)
      request = build_api_request_for_update_content(upload_type: upload_type, file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, add_parents: add_parents, enforce_single_parent: enforce_single_parent, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, remove_parents: remove_parents, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, body: body)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#update_content\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return File.from_json(data), status_code, headers
    end

    # Updates a file&#39;s metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.
    # @param upload_type [String] The type of upload request to the /upload URI
    # @param file_id [String] The ID of the file.
    # @return nil
    def update_content(*, upload_type : String = "media", file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, add_parents : String? = nil, enforce_single_parent : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, remove_parents : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, body : ::File? = nil, &block : Crest::Response ->)
      build_api_request_for_update_content(upload_type: upload_type, file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, add_parents: add_parents, enforce_single_parent: enforce_single_parent, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, remove_parents: remove_parents, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, body: body).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_update_content(*, upload_type : String = "media", file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, add_parents : String? = nil, enforce_single_parent : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, remove_parents : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, body : ::File? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.update_content ..." }
      end
      # verify enum value
      allowable_values = ["media", "multipart", "resumable"]
      if @api_client.config.client_side_validation && !allowable_values.includes?(upload_type)
        raise ArgumentError.new("invalid value for \"upload_type\", must be one of #{allowable_values}")
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/upload/drive/v3/files/{fileId}".sub("{" + "fileId" + "}", URI.encode_path(file_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["uploadType"] = upload_type.to_s if !upload_type.nil?
      query_params["addParents"] = add_parents.to_s if !add_parents.nil?
      query_params["enforceSingleParent"] = enforce_single_parent.to_s if !enforce_single_parent.nil?
      query_params["includePermissionsForView"] = include_permissions_for_view.to_s if !include_permissions_for_view.nil?
      query_params["keepRevisionForever"] = keep_revision_forever.to_s if !keep_revision_forever.nil?
      query_params["ocrLanguage"] = ocr_language.to_s if !ocr_language.nil?
      query_params["removeParents"] = remove_parents.to_s if !remove_parents.nil?
      query_params["supportsAllDrives"] = supports_all_drives.to_s if !supports_all_drives.nil?
      query_params["supportsTeamDrives"] = supports_team_drives.to_s if !supports_team_drives.nil?
      query_params["useContentAsIndexableText"] = use_content_as_indexable_text.to_s if !use_content_as_indexable_text.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/octet-stream"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = body

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"PATCH",
        path: local_var_path,
        operation: "FilesApi.drive_files_update_content",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Creates a new file.
    # @param upload_type [String] The type of upload request to the /upload URI
    # @return [File]
    def upload(*, upload_type : String = "multipart", alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, media : ::File? = nil, metadata : ::File? = nil)
      data, _status_code, _headers = upload_with_http_info(upload_type: upload_type, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, ignore_default_visibility: ignore_default_visibility, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, media: media, metadata: metadata)
      data
    end

    # Creates a new file.
    # @param upload_type [String] The type of upload request to the /upload URI
    # @return [Array<(File, Integer, Hash)>] File data, response status code and response headers
    def upload_with_http_info(*, upload_type : String = "multipart", alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, media : ::File? = nil, metadata : ::File? = nil)
      request = build_api_request_for_upload(upload_type: upload_type, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, ignore_default_visibility: ignore_default_visibility, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, media: media, metadata: metadata)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#upload\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return File.from_json(data), status_code, headers
    end

    # Creates a new file.
    # @param upload_type [String] The type of upload request to the /upload URI
    # @return nil
    def upload(*, upload_type : String = "multipart", alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, media : ::File? = nil, metadata : ::File? = nil, &block : Crest::Response ->)
      build_api_request_for_upload(upload_type: upload_type, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, enforce_single_parent: enforce_single_parent, ignore_default_visibility: ignore_default_visibility, include_permissions_for_view: include_permissions_for_view, keep_revision_forever: keep_revision_forever, ocr_language: ocr_language, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, use_content_as_indexable_text: use_content_as_indexable_text, media: media, metadata: metadata).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_upload(*, upload_type : String = "multipart", alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, enforce_single_parent : Bool? = nil, ignore_default_visibility : Bool? = nil, include_permissions_for_view : String? = nil, keep_revision_forever : Bool? = nil, ocr_language : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, use_content_as_indexable_text : Bool? = nil, media : ::File? = nil, metadata : ::File? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.upload ..." }
      end
      # verify enum value
      allowable_values = ["media", "multipart", "resumable"]
      if @api_client.config.client_side_validation && !allowable_values.includes?(upload_type)
        raise ArgumentError.new("invalid value for \"upload_type\", must be one of #{allowable_values}")
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/upload/drive/v3/files"

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["uploadType"] = upload_type.to_s if !upload_type.nil?
      query_params["enforceSingleParent"] = enforce_single_parent.to_s if !enforce_single_parent.nil?
      query_params["ignoreDefaultVisibility"] = ignore_default_visibility.to_s if !ignore_default_visibility.nil?
      query_params["includePermissionsForView"] = include_permissions_for_view.to_s if !include_permissions_for_view.nil?
      query_params["keepRevisionForever"] = keep_revision_forever.to_s if !keep_revision_forever.nil?
      query_params["ocrLanguage"] = ocr_language.to_s if !ocr_language.nil?
      query_params["supportsAllDrives"] = supports_all_drives.to_s if !supports_all_drives.nil?
      query_params["supportsTeamDrives"] = supports_team_drives.to_s if !supports_team_drives.nil?
      query_params["useContentAsIndexableText"] = use_content_as_indexable_text.to_s if !use_content_as_indexable_text.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["multipart/form-data"])

      # form parameters
      form_params = Hash(String, (String | Array(String) | ::File)).new
      form_params["Media"] = media if !media.nil?
      form_params["Metadata"] = metadata if !metadata.nil?

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "FilesApi.drive_files_upload",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Subscribes to changes to a file. While you can establish a channel for changes to a file on a shared drive, a change to a shared drive file won't create a notification.
    # @param file_id [String] The ID of the file.
    # @return [Channel]
    def watch(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, acknowledge_abuse : Bool? = nil, include_permissions_for_view : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, channel : Channel? = nil)
      data, _status_code, _headers = watch_with_http_info(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, acknowledge_abuse: acknowledge_abuse, include_permissions_for_view: include_permissions_for_view, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, channel: channel)
      data
    end

    # Subscribes to changes to a file. While you can establish a channel for changes to a file on a shared drive, a change to a shared drive file won&#39;t create a notification.
    # @param file_id [String] The ID of the file.
    # @return [Array<(Channel, Integer, Hash)>] Channel data, response status code and response headers
    def watch_with_http_info(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, acknowledge_abuse : Bool? = nil, include_permissions_for_view : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, channel : Channel? = nil)
      request = build_api_request_for_watch(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, acknowledge_abuse: acknowledge_abuse, include_permissions_for_view: include_permissions_for_view, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, channel: channel)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: FilesApi#watch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Channel.from_json(data), status_code, headers
    end

    # Subscribes to changes to a file. While you can establish a channel for changes to a file on a shared drive, a change to a shared drive file won&#39;t create a notification.
    # @param file_id [String] The ID of the file.
    # @return nil
    def watch(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, acknowledge_abuse : Bool? = nil, include_permissions_for_view : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, channel : Channel? = nil, &block : Crest::Response ->)
      build_api_request_for_watch(file_id: file_id, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, acknowledge_abuse: acknowledge_abuse, include_permissions_for_view: include_permissions_for_view, supports_all_drives: supports_all_drives, supports_team_drives: supports_team_drives, channel: channel).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_watch(*, file_id : String, alt : String? = "json", fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, acknowledge_abuse : Bool? = nil, include_permissions_for_view : String? = nil, supports_all_drives : Bool? = nil, supports_team_drives : Bool? = nil, channel : Channel? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: FilesApi.watch ..." }
      end
      allowable_values = ["json", "media"]
      if @api_client.config.client_side_validation && !alt.nil? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/drive/v3/files/{fileId}/watch".sub("{" + "fileId" + "}", URI.encode_path(file_id.to_s))

      # query parameters
      query_params = Hash(String, (String | Array(String))).new
      query_params["alt"] = alt.to_s if !alt.nil?
      query_params["fields"] = fields.to_s if !fields.nil?
      query_params["key"] = key.to_s if !key.nil?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil?
      query_params["acknowledgeAbuse"] = acknowledge_abuse.to_s if !acknowledge_abuse.nil?
      query_params["includePermissionsForView"] = include_permissions_for_view.to_s if !include_permissions_for_view.nil?
      query_params["supportsAllDrives"] = supports_all_drives.to_s if !supports_all_drives.nil?
      query_params["supportsTeamDrives"] = supports_team_drives.to_s if !supports_team_drives.nil?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = channel.to_json

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "FilesApi.drive_files_watch",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end
  end
end
